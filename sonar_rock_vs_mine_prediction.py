# -*- coding: utf-8 -*-
"""Sonar Rock vs Mine prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xqrQfLauWd7jZRqO3Qm-VpDt9oOIoLZc

Importing the dependencies
"""

import numpy as np # Basically to deal with arrays
 import pandas as pd # It is built on top of another package named Numpy, which provides support for multi-dimensional arrays and for data processing steps

 from sklearn.model_selection import train_test_split # train_test_split is a function in Sklearn model selection for splitting data arrays into two subsets: for training data and for testing data. With this function, you don't need to divide the dataset manually. By default, Sklearn train_test_split will make random partitions for the two subsets
 from sklearn.linear_model import LogisticRegression
 from sklearn.metrics import accuracy_score

"""Data Collection and Data Processing"""

# Loading the data set into pandas data frame
sonar_data = pd.read_csv('/content/sonar data.csv', header=None) # header = None , because our dataset do not have column names

sonar_data.head() # This will read first five rows of our dataset

# To find number of rows and columns
sonar_data.shape

# To get statistical definition for the data
sonar_data.describe()

# Check for how many examples exist for each rock and mines
sonar_data[60].value_counts() # value_counts(): Return a Series containing counts of unique rows in the DataFrame.
                              # almost equal number of examples for mines and rock will give good predictions and thus good accuracy score
                              # More the data more accurate is the model

"""M --->> Mine
R --->> Rock
           Grouping of data based on M and R
"""

sonar_data.groupby(60).mean()

# separating data and labels(R and M)
# This is a supervised machine learning problem where on the basis of label model will give its predictions

X = sonar_data.drop(columns=60 ,axis=1)
Y = sonar_data[60]
print(X)
print(Y)

"""Training and Test data"""

X_train , X_test , Y_train , Y_test = train_test_split(X, Y, test_size =0.1, stratify=Y, random_state=1)

print(X.shape , X_train.shape , X_test.shape)

print(Y.shape , Y_train.shape , Y_test.shape)

"""Model training based on train_data --> Logistic Regression

"""

model = LogisticRegression()

# Training the logistic regression model with training data
print(X_train)
print(Y_train)

model.fit(X_train , Y_train)

"""Model Evaluation

"""

#Accuracy on training data
#Most of the time accuracy on training data is more
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction , Y_train)
print("Accuracy on training data :",training_data_accuracy)

#Accuracy on test data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction , Y_test)
print("Accuracy on test data :",test_data_accuracy)

"""Making a Prediction System"""

#input_data = (0.02,0.0371,0.0428,0.0207,0.0954,0.0986,0.1539,0.1601,0.3109,0.2111,0.1609,0.1582,0.2238,0.0645,0.066,0.2273,0.31,0.2999,0.5078,0.4797,0.5783,0.5071,0.4328,0.555,0.6711,0.6415,0.7104,0.808,0.6791,0.3857,0.1307,0.2604,0.5121,0.7547,0.8537,0.8507,0.6692,0.6097,0.4943,0.2744,0.051,0.2834,0.2825,0.4256,0.2641,0.1386,0.1051,0.1343,0.0383,0.0324,0.0232,0.0027,0.0065,0.0159,0.0072,0.0167,0.018,0.0084,0.009,0.0032)
input_data =(0.0307,0.0523,0.0653,0.0521,0.0611,0.0577,0.0665,0.0664,0.146,0.2792,0.3877,0.4992,0.4981,0.4972,0.5607,0.7339,0.823,0.9173,0.9975,0.9911,0.824,0.6498,0.598,0.4862,0.315,0.1543,0.0989,0.0284,0.1008,0.2636,0.2694,0.293,0.2925,0.3998,0.366,0.3172,0.4609,0.4374,0.182,0.3376,0.6202,0.4448,0.1863,0.142,0.0589,0.0576,0.0672,0.0269,0.0245,0.019,0.0063,0.0321,0.0189,0.0137,0.0277,0.0152,0.0052,0.0121,0.0124,0.0055)

# changing input data to numpy array for faster computation
input_data_as_numpy_array = np.asarray(input_data)

# reshape the np array as we are predicting for one instance
input_data_rehshaped = input_data_as_numpy_array.reshape(1 , -1) #Reshape your data using array.reshape(1, -1) if it contains a single sample

prediction = model.predict(input_data_rehshaped)
print(prediction)

if prediction[0]=='R':
  print("The object is a rock")
else:
  print("The object is a mine")

